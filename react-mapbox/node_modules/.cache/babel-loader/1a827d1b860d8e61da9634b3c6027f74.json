{"ast":null,"code":"// @ts-ignore\nimport * as turf from \"@turf/turf\";\nexport async function getTrackingData(lastIndex, url, drawData, deviceId) {\n  let data;\n\n  try {\n    data = await fetch(`${url}=${lastIndex}&track_id=${deviceId}&short=true`, {\n      method: \"GET\"\n    }).then(res => res.json());\n  } catch (error) {\n    console.log(error);\n  }\n\n  if (data) {\n    const pointsData = data.track[0].points;\n    const startPoint = data.track[0].start_point;\n    const multiplier = data.track[0].multiplier;\n\n    if (pointsData.length !== 0) {\n      const nextIndex = data.track[0].last_index;\n      let convertData = [];\n\n      for (let i = 0; i < pointsData.length; i += 2) {\n        const pair = [pointsData[i + 1] * multiplier + startPoint[1], pointsData[i] * multiplier + startPoint[0]];\n        convertData.push(pair);\n      } // const convertData = pointsData.for((coordinate: number, index: number) => [\n      //   if(index%2===1)\n      //   return\n      //   coordinate.x * multiplier + startPoint[0],\n      //   coordinate.y * multiplier + startPoint[1],\n      // ]);\n\n\n      drawData(prevState => {\n        if (prevState) {\n          return {\n            type: \"geojson\",\n            data: turf.lineString(prevState === null || prevState === void 0 ? void 0 : prevState.data.geometry.coordinates.concat(convertData))\n          };\n        } else return {\n          type: \"geojson\",\n          data: turf.lineString(convertData)\n        };\n      });\n      getTrackingData(nextIndex, url, drawData, deviceId);\n    } else {\n      setTimeout(() => {\n        getTrackingData(lastIndex, url, drawData, deviceId);\n      }, 700);\n    }\n  }\n}","map":{"version":3,"sources":["E:/imet/mapbox-module/react-mapbox/src/Mapbox/getTrackingData.ts"],"names":["turf","getTrackingData","lastIndex","url","drawData","deviceId","data","fetch","method","then","res","json","error","console","log","pointsData","track","points","startPoint","start_point","multiplier","length","nextIndex","last_index","convertData","i","pair","push","prevState","type","lineString","geometry","coordinates","concat","setTimeout"],"mappings":"AAAA;AACA,OAAO,KAAKA,IAAZ,MAAsB,YAAtB;AAEA,OAAO,eAAeC,eAAf,CACLC,SADK,EAELC,GAFK,EAGLC,QAHK,EAILC,QAJK,EAKL;AACA,MAAIC,IAAJ;;AACA,MAAI;AACFA,IAAAA,IAAI,GAAG,MAAMC,KAAK,CAAE,GAAEJ,GAAI,IAAGD,SAAU,aAAYG,QAAS,aAA1C,EAAwD;AACxEG,MAAAA,MAAM,EAAE;AADgE,KAAxD,CAAL,CAEVC,IAFU,CAEJC,GAAD,IAASA,GAAG,CAACC,IAAJ,EAFJ,CAAb;AAGD,GAJD,CAIE,OAAOC,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;;AACD,MAAIN,IAAJ,EAAU;AACR,UAAMS,UAAU,GAAGT,IAAI,CAACU,KAAL,CAAW,CAAX,EAAcC,MAAjC;AACA,UAAMC,UAAU,GAAGZ,IAAI,CAACU,KAAL,CAAW,CAAX,EAAcG,WAAjC;AACA,UAAMC,UAAU,GAAGd,IAAI,CAACU,KAAL,CAAW,CAAX,EAAcI,UAAjC;;AACA,QAAIL,UAAU,CAACM,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,YAAMC,SAAS,GAAGhB,IAAI,CAACU,KAAL,CAAW,CAAX,EAAcO,UAAhC;AAEA,UAAIC,WAAkB,GAAG,EAAzB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,UAAU,CAACM,MAA/B,EAAuCI,CAAC,IAAE,CAA1C,EAA6C;AAC3C,cAAMC,IAAI,GAAG,CACXX,UAAU,CAACU,CAAC,GAAG,CAAL,CAAV,GAAoBL,UAApB,GAAiCF,UAAU,CAAC,CAAD,CADhC,EAEXH,UAAU,CAACU,CAAD,CAAV,GAAgBL,UAAhB,GAA6BF,UAAU,CAAC,CAAD,CAF5B,CAAb;AAIAM,QAAAA,WAAW,CAACG,IAAZ,CAAiBD,IAAjB;AACD,OAX0B,CAa3B;AACA;AACA;AACA;AACA;AACA;;;AAEAtB,MAAAA,QAAQ,CAAEwB,SAAD,IAAoB;AAC3B,YAAIA,SAAJ,EAAe;AACb,iBAAO;AACLC,YAAAA,IAAI,EAAE,SADD;AAELvB,YAAAA,IAAI,EAAEN,IAAI,CAAC8B,UAAL,CACJF,SADI,aACJA,SADI,uBACJA,SAAS,CAAEtB,IAAX,CAAgByB,QAAhB,CAAyBC,WAAzB,CAAqCC,MAArC,CAA4CT,WAA5C,CADI;AAFD,WAAP;AAMD,SAPD,MAQE,OAAO;AACLK,UAAAA,IAAI,EAAE,SADD;AAELvB,UAAAA,IAAI,EAAEN,IAAI,CAAC8B,UAAL,CAAgBN,WAAhB;AAFD,SAAP;AAIH,OAbO,CAAR;AAcAvB,MAAAA,eAAe,CAACqB,SAAD,EAAYnB,GAAZ,EAAiBC,QAAjB,EAA2BC,QAA3B,CAAf;AACD,KAnCD,MAmCO;AACL6B,MAAAA,UAAU,CAAC,MAAM;AACfjC,QAAAA,eAAe,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,QAAjB,EAA2BC,QAA3B,CAAf;AACD,OAFS,EAEP,GAFO,CAAV;AAGD;AACF;AACF","sourcesContent":["// @ts-ignore\r\nimport * as turf from \"@turf/turf\";\r\n\r\nexport async function getTrackingData(\r\n  lastIndex: number,\r\n  url: string,\r\n  drawData: any,\r\n  deviceId: number\r\n) {\r\n  let data;\r\n  try {\r\n    data = await fetch(`${url}=${lastIndex}&track_id=${deviceId}&short=true`, {\r\n      method: \"GET\",\r\n    }).then((res) => res.json());\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n  if (data) {\r\n    const pointsData = data.track[0].points;\r\n    const startPoint = data.track[0].start_point;\r\n    const multiplier = data.track[0].multiplier;\r\n    if (pointsData.length !== 0) {\r\n      const nextIndex = data.track[0].last_index;\r\n\r\n      let convertData: any[] = [];\r\n\r\n      for (let i = 0; i < pointsData.length; i+=2) {\r\n        const pair = [\r\n          pointsData[i + 1] * multiplier + startPoint[1],\r\n          pointsData[i] * multiplier + startPoint[0],\r\n        ];\r\n        convertData.push(pair)\r\n      }\r\n\r\n      // const convertData = pointsData.for((coordinate: number, index: number) => [\r\n      //   if(index%2===1)\r\n      //   return\r\n      //   coordinate.x * multiplier + startPoint[0],\r\n      //   coordinate.y * multiplier + startPoint[1],\r\n      // ]);\r\n\r\n      drawData((prevState: any) => {\r\n        if (prevState) {\r\n          return {\r\n            type: \"geojson\",\r\n            data: turf.lineString(\r\n              prevState?.data.geometry.coordinates.concat(convertData)\r\n            ),\r\n          };\r\n        } else\r\n          return {\r\n            type: \"geojson\",\r\n            data: turf.lineString(convertData),\r\n          };\r\n      });\r\n      getTrackingData(nextIndex, url, drawData, deviceId);\r\n    } else {\r\n      setTimeout(() => {\r\n        getTrackingData(lastIndex, url, drawData, deviceId);\r\n      }, 700);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}